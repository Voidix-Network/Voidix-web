import { minify } from 'html-minifier-terser';
import puppeteer from 'puppeteer';
import { createLogger } from '../utils/logger.js';

const logger = createLogger('PuppeteerRenderer');

/**
 * Puppeteer渲染器
 * 负责使用Puppeteer进行页面预渲染
 */
export class PuppeteerRenderer {
  constructor(config) {
    this.config = config;
    this.browser = null;

    // 🔥 HTML终极压缩配置 - 极限优化
    this.minifyOptions = {
      // === 基础压缩 ===
      collapseWhitespace: true,        // ✅ 压缩空白符
      removeComments: true,            // ✅ 移除注释
      removeRedundantAttributes: true, // ✅ 移除冗余属性
      removeScriptTypeAttributes: true,// ✅ 移除script type
      removeStyleLinkTypeAttributes: true, // ✅ 移除style/link type
      useShortDoctype: true,           // ✅ 使用短DOCTYPE
      removeEmptyAttributes: true,     // ✅ 移除空属性
      html5: true,                     // ✅ HTML5模式
      caseSensitive: false,            // ✅ 大小写不敏感

      // === 🔥 极限压缩选项 ===
      removeOptionalTags: true,        // 🔥 移除可选标签（如</li>, </p>）
      removeAttributeQuotes: true,     // 🔥 移除属性引号（id=test而非id="test"）
      removeEmptyElements: true,       // 🔥 移除空元素
      collapseBooleanAttributes: true, // 🔥 压缩布尔属性（checked而非checked="checked"）
      collapseInlineTagWhitespace: true, // 🔥 压缩内联标签空白
      conservativeCollapse: false,     // 🔥 激进空白压缩
      decodeEntities: true,            // 🔥 解码HTML实体
      includeAutoGeneratedTags: false, // 🔥 不包含自动生成标签
      keepClosingSlash: false,         // 🔥 移除自闭合标签的斜杠
      processConditionalComments: true, // 🔥 处理条件注释
      processScripts: ['text/html'],   // 🔥 处理脚本内容
      removeTagWhitespace: true,       // 🔥 移除标签间空白
      sortAttributes: true,            // 🔥 排序属性（减少gzip重复）
      sortClassName: true,             // 🔥 排序class名（减少gzip重复）
      trimCustomFragments: true,       // 🔥 修剪自定义片段

      // === CSS/JS 内联压缩 ===
      minifyCSS: {
        level: 2,                      // 🔥 CSS最高级别压缩
        compatibility: '*',            // 🔥 忽略兼容性警告
      },
      minifyJS: {
        compress: {
          drop_console: true,          // 🔥 移除console
          drop_debugger: true,         // 🔥 移除debugger
          pure_funcs: ['console.log'], // 🔥 纯函数优化
        },
        mangle: true,                  // 🔥 混淆变量名
        format: {
          comments: false,             // 🔥 移除所有注释
        },
      },

      // === 高级选项 ===
      ignoreCustomComments: [/^!/],   // 保留重要注释（如许可证）
      maxLineLength: 0,                // 🔥 无行长度限制（单行输出）
      preserveLineBreaks: false,       // 🔥 不保留换行符
      preventAttributesEscaping: false, // 🔥 允许属性转义优化
      quoteCharacter: '"',             // 统一引号风格

      ...config.htmlMinify || {}
    };
  }

  /**
   * 初始化浏览器
   */
  async initBrowser() {
    try {
      logger.start('启动Puppeteer浏览器');
      this.browser = await puppeteer.launch(this.config.puppeteer);
      logger.success('Puppeteer浏览器启动成功');
      return true;
    } catch (error) {
      logger.error('Puppeteer浏览器启动失败', error);
      return false;
    }
  }

  /**
   * 预渲染单个路由
   */
  async renderRoute(route, serverPort) {
    const { path: routePath, outputDir } = route;
    const url = `http://localhost:${serverPort}${routePath}`;

    logger.step(`预渲染路由: ${routePath}`);

    try {
      const page = await this.browser.newPage();

      // 🚀 优化：禁用可能造成阻塞的功能
      await page.setRequestInterception(true);
      page.on('request', (request) => {
        const resourceType = request.resourceType();
        // 阻止可能造成TBT的资源
        if (['websocket', 'eventsource', 'font', 'media', 'image'].includes(resourceType)) {
          request.abort();
        } else {
          request.continue();
        }
      });

      // 🚀 优化：注入环境变量，禁用WebSocket等
      await page.evaluateOnNewDocument(() => {
        // 禁用WebSocket连接
        window.PRERENDER_MODE = true;
        window.DISABLE_WEBSOCKET = true;

        // 模拟WebSocket以防止错误
        window.WebSocket = class MockWebSocket {
          constructor() {
            this.readyState = 3; // CLOSED
          }
          send() {}
          close() {}
          addEventListener() {}
          removeEventListener() {}
        };

        // 禁用一些可能阻塞的API
        window.fetch = () => Promise.resolve(new Response('{}'));

        // 加速定时器
        const originalSetTimeout = window.setTimeout;
        window.setTimeout = (fn, delay) => originalSetTimeout(fn, Math.min(delay, 100));
      });

      // 设置视口
      await page.setViewport({
        width: this.config.render.viewportWidth,
        height: this.config.render.viewportHeight,
      });

      // 🚀 优化：更快的页面加载策略
      await page.goto(url, {
        waitUntil: 'domcontentloaded', // 不等待所有资源加载
        timeout: this.config.render.timeout,
      });

      // 🚀 优化：等待React渲染完成但限制等待时间
      try {
        await page.waitForFunction(
          () => {
            // 检查React是否渲染完成，特别检查主要内容是否存在
            const root = document.querySelector('#root');
            if (!root || root.children.length === 0) return false;

            // 检查是否还在显示加载状态
            const loadingElement = document.querySelector('.loading-fade-in');
            if (loadingElement) return false;

            // 检查主要内容是否已渲染
            const mainContent = document.querySelector('main');
            if (!mainContent) return false;

            // 检查h1标签是否存在（为了SEO）
            const h1Element = document.querySelector('h1');
            if (!h1Element) return false;

            return true;
          },
          { timeout: 8000 } // 增加到8秒等待时间
        );

        // 额外等待一些动画完成
        await page.waitForTimeout(1000);

      } catch (timeoutError) {
        logger.warn(`等待渲染完成超时: ${routePath}, 继续使用当前状态`);

        // 超时后检查当前状态
        const hasH1 = await page.$('h1');
        if (!hasH1) {
          logger.error(`⚠️ 未检测到h1标签: ${routePath}`);
        }
      }

      // 获取初始的、包含骨架屏的HTML
      let html = await page.content();

      // 压缩HTML
      try {
        const minifiedHtml = await minify(html, this.minifyOptions);
        const originalSize = html.length;
        const minifiedSize = minifiedHtml.length;
        const compression = ((originalSize - minifiedSize) / originalSize * 100).toFixed(1);

        logger.info(`  HTML压缩: ${originalSize} → ${minifiedSize} 字符 (减少 ${compression}%)`);
        html = minifiedHtml;
      } catch (minifyError) {
        logger.warn(`HTML压缩失败，使用原始HTML: ${minifyError.message}`);
      }

      // 关闭页面
      await page.close();

      logger.success(`预渲染完成: ${routePath}`);

      return {
        route: routePath,
        outputDir,
        html,
        size: html.length,
      };
    } catch (error) {
      logger.error(`预渲染失败: ${routePath}`, error);
      return null;
    }
  }

  /**
   * 批量预渲染路由
   */
  async renderRoutes(routes, serverPort) {
    const results = [];

    for (const route of routes) {
      const result = await this.renderRoute(route, serverPort);
      if (result) {
        results.push(result);
      }
    }

    return results;
  }

  /**
   * 关闭浏览器
   */
  async closeBrowser() {
    try {
      if (this.browser) {
        await this.browser.close();
        logger.success('Puppeteer浏览器已关闭');
      }
    } catch (error) {
      logger.error('关闭Puppeteer浏览器失败', error);
    }
  }
}
